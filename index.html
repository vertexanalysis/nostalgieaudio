<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Radio Nostalgie – Embed Player</title>
  <style>
    :root{
      --bg:#0e0e12; --card:#151722; --muted:#8b90a5; --text:#eef1f7;
      --accent:#ff4d6d; --accent-2:#ff7a59; --border:#232633;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Helvetica,Arial,sans-serif;
      color:var(--text); background:transparent;
    }
    .player{
      display:flex; align-items:stretch; gap:0; position:relative;
      width:100%; border:1px solid #2a2a2a; border-radius:8px; overflow:hidden;
      background:#202224;
      box-shadow:0 6px 18px rgba(0,0,0,.35);
    }
    .cover{
      flex:0 0 180px; height:180px;
      position:relative; overflow:hidden; display:flex; align-items:center; justify-content:center;
      background:#0a0b11;
    }
    .cover img {
      height: 100%;
      width: auto;
      object-fit: contain;
      object-position: center bottom;
      display: block;
      background: #0a0b11;
    }
    .cover::after{ content:""; position:absolute; inset:0; background:linear-gradient(0deg,rgba(0,0,0,.25),rgba(0,0,0,0)) }

    .right{ flex:1; display:flex; flex-direction:column; justify-content:center; min-height:160px; padding:12px 18px }
    .meta{flex:0 0 auto; margin-bottom:8px}
    .title{font-weight:700; font-size:26px; line-height:1.2; margin:0 0 4px}
    .artist{margin:0; font-size:16px; color:#b9bed0; line-height:1.4; word-wrap:break-word; overflow-wrap:break-word}

    .controls{display:flex; align-items:center; gap:12px; margin-top:6px}
    .btn{appearance:none; border:none; cursor:pointer; display:inline-grid; place-items:center; width:64px;height:64px;border-radius:50%; background:#e35a1d; color:#fff}
    .btn svg{width:20px;height:20px;fill:currentColor}

    .range{flex:1; display:flex; align-items:center; gap:8px}
    .range input[type="range"]{width:100%}
    input[type="range"]{ -webkit-appearance:none; appearance:none; height:4px; border-radius:999px; background:#2b3044; outline:none }
    input[type="range"]::-webkit-slider-thumb{ -webkit-appearance:none; appearance:none; width:14px; height:14px; border-radius:50%; background:var(--accent-2)}
    input[type="range"]::-moz-range-thumb{ width:14px; height:14px; border:none; border-radius:50%; background:var(--accent-2) }

    .ticker{ display:none }
    .footer{ display:none }
    .brand-watermark{ position:absolute; right:12px; bottom:8px; font-size:12px; color:#c9cedd; opacity:.92; letter-spacing:.2px; pointer-events:none; white-space:nowrap }
    .brand-watermark-cover{ position:absolute; left:50%; transform:translateX(-50%); bottom:8px; font-size:11px; color:#c9cedd; opacity:.92; letter-spacing:.2px; pointer-events:none; white-space:nowrap; display:none }
    @media (max-width: 560px){
      .brand-watermark{ display:none }
      .brand-watermark-cover{ display:block }
      .title{ font-size:20px }
      .artist{ font-size:14px; line-height:1.5 }
    }
  </style>
</head>
<body>
  <div class="player" id="player">
    <div class="cover" id="cover">
      <img id="coverImg" alt="Обложка" decoding="async" src="nostalgielogo.jpeg"
        style="height:100%;width:auto;display:block;background:#0a0b11" />
      <div class="brand-watermark-cover">Nostalgie Махачкала</div>
    </div>
    <div class="right">
      <div class="meta">
        <h1 class="title" id="title">Загрузка…</h1>
        <p class="artist" id="artist">—</p>
      </div>
      <div class="controls">
        <button class="btn" id="playBtn" aria-label="Воспроизвести">
          <svg id="playIcon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
        </button>
        <div class="range">
          <svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true"><path fill="currentColor" d="M4 10v4h3l4 4V6L7 10H4zm13.5 2a4.5 4.5 0 0 0-2.25-3.9v7.8A4.5 4.5 0 0 0 17.5 12zm-2.25-7.32v2.06a7 7 0 0 1 0 10.52v2.06c3.05-1.27 5.2-4.28 5.2-7.64s-2.15-6.37-5.2-7.64z"/></svg>
          <input id="volume" type="range" min="0" max="1" step="0.01" value="0.66" />
        </div>
      </div>

    </div>
    <div class="brand-watermark">Nostalgie Махачкала</div>
  </div>

  <audio id="audio" preload="none" crossorigin="anonymous"></audio>

  <script>
  ;(() => {
    const params = new URLSearchParams(location.search)
    const cfg = {
      streamUrl: params.get('stream') || 'https://nostalgie.dagfm.ru/',
      metaEndpoints: (params.get('meta') || 'http://193.168.3.158:8000,https://status.rcast.net/71073,https://nostalgie.dagfm.ru/api/nowplaying,https://nostalgie.dagfm.ru/7.html')
        .split(',').map(s => s.trim()).filter(Boolean),
      // Prefer dynamic covers via coverTpl when provided; only use fixed cover if no template
      cover: params.get('cover') || '',
      coverTpl: params.get('coverTpl') || '',
      providerCover: params.get('providerCover') || '',
      providerCoverTpl: params.get('providerCoverTpl') || '',
      defaultCover: params.get('defaultCover') || 'nostalgielogo.jpeg',
      autoCover: params.get('autoCover') !== '0',
      fastMs: Number(params.get('fastMs') || 1500),
      refreshMs: Number(params.get('refreshMs') || 3000),
      // if empty, we'll auto-fallback to a public proxy (allorigins)
      proxy: params.get('proxy') || '',
      appleProxy: params.get('appleProxy') || ''
    }
    const isIOS = /iP(hone|ad|od)/.test(navigator.userAgent)

    const audio = document.getElementById('audio')
    const playBtn = document.getElementById('playBtn')
    const playIcon = document.getElementById('playIcon')
    const vol = document.getElementById('volume')
    const titleEl = document.getElementById('title')
    const artistEl = document.getElementById('artist')
    const coverEl = document.getElementById('cover')
    // ---- helpers (no status/ticker in production) ----
    function setStatus(_msg){}
    function setTicker(_msg){}

    // ---- audio wiring ----
    audio.src = cfg.streamUrl
    audio.volume = parseFloat(vol.value)

    playBtn.addEventListener('click', async () => {
      if (audio.paused) {
        // Optimistic UI: switch icon immediately
        playIcon.innerHTML = '<path d="M6 6h4v12H6zM14 6h4v12h-4z"/>'
        try {
          await audio.play()
          setStatus('проигрывается')
        } catch (e) {
          // revert if autoplay blocked / error
          playIcon.innerHTML = '<path d="M8 5v14l11-7z"/>'
          setStatus('нажмите воспроизвести')
        }
      } else {
        // Switch icon first, then pause
        playIcon.innerHTML = '<path d="M8 5v14l11-7z"/>'
        audio.pause()
        setStatus('пауза')
      }
    })

    vol.addEventListener('input', () => audio.volume = parseFloat(vol.value))
    // Nudge metadata refresh promptly on key UX events (helps iOS)
    audio.addEventListener('playing', () => { try { updateMeta() } catch(_){} })
    audio.addEventListener('pause',   () => { try { updateMeta() } catch(_){} })
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) { try { updateMeta() } catch(_){} }
    })
    // production: no status indicators

    // ---- networking ----
    let lastSongKey = ''
    let lastCoverAttemptKey = ''
    let lastCoverAttemptTs = 0

    // Simple cache for iTunes API results to avoid rate limiting
    const itunesCache = new Map()
    const CACHE_DURATION = 10 * 60 * 1000 // 10 minutes

    // Metadata cache with shorter duration since songs change frequently
    const metadataCache = new Map()
    const METADATA_CACHE_DURATION = 15 * 1000 // 15 seconds - shorter for faster updates

    // Continuous metadata fetching state
    let continuousMetadataActive = false
    let lastMetadataResult = null
    let metadataFetchCount = 0

    async function fetchWithTimeout(url, ms=7000, init={}){
      const ctrl = new AbortController()
      const id = setTimeout(() => ctrl.abort(), ms)
      try { return await fetch(url, {signal: ctrl.signal, ...init}) }
      finally { clearTimeout(id) }
    }

    function proxied(url){ return cfg.proxy ? `${cfg.proxy}${encodeURIComponent(url)}` : url }

    // Robust metadata fetching with multiple proxy fallbacks (similar to iTunes API)
    async function fetchMetadataRobust(url) {
      // Check cache first (short duration since metadata changes frequently)
      const cacheKey = url
      const cached = metadataCache.get(cacheKey)
      if (cached && Date.now() - cached.timestamp < METADATA_CACHE_DURATION) {
        console.log('[DEBUG] Using cached metadata result')
        return cached.data
      }

      // Add cache-buster to avoid intermediates
      const u = new URL(url, location.href)
      u.searchParams.set('_', Date.now().toString())
      const finalUrl = u.toString()

      // Multiple proxy services optimized for speed and reliability
      const metadataProxyServices = [
        {
          name: 'Direct',
          url: finalUrl,
          timeout: 3000,  // Very fast timeout for direct
          parseResponse: async (response) => ({
            text: await response.text(),
            contentType: (response.headers.get('content-type') || '').toLowerCase()
          })
        },
        {
          name: 'AllOrigins',
          url: 'https://api.allorigins.win/raw?url=' + encodeURIComponent(finalUrl),
          timeout: 4000,
          parseResponse: async (response) => ({
            text: await response.text(),
            contentType: (response.headers.get('content-type') || '').toLowerCase()
          })
        },
        {
          name: 'Jina',
          url: 'https://r.jina.ai/http://' + finalUrl.replace(/^https?:\/\//, ''),
          timeout: 4000,
          parseResponse: async (response) => {
            const text = await response.text()
            // For Jina, try to extract content from markdown wrapper
            const contentMatch = text.match(/```(?:json|text)?\s*\n?([\s\S]*?)\n?```/)
            const actualContent = contentMatch ? contentMatch[1] : text
            return {
              text: actualContent.trim(),
              contentType: 'text/plain'  // Jina doesn't preserve headers
            }
          }
        },
        {
          name: 'CORS-Anywhere',
          url: 'https://cors-anywhere.herokuapp.com/' + finalUrl,
          timeout: 4000,
          parseResponse: async (response) => ({
            text: await response.text(),
            contentType: (response.headers.get('content-type') || '').toLowerCase()
          })
        }
      ]

      console.log('[DEBUG] Trying multiple proxy services for metadata:', finalUrl)

      // Try each service with fast failover
      for (const service of metadataProxyServices) {
        try {
          console.log(`[DEBUG] Trying ${service.name} for metadata:`, service.url)
          const response = await fetchWithTimeout(service.url, service.timeout)

          if (response.ok) {
            const parsed = await service.parseResponse(response)
            console.log(`[DEBUG] ${service.name} metadata success!`)
            const result = {
              res: {
                ok: true,
                status: response.status,
                text: () => Promise.resolve(parsed.text),
                json: () => {
                  try {
                    return Promise.resolve(JSON.parse(parsed.text))
                  } catch (e) {
                    return Promise.reject(new Error('Invalid JSON'))
                  }
                },
                headers: {
                  get: (name) => name.toLowerCase() === 'content-type' ? parsed.contentType : null
                }
              },
              via: service.name.toLowerCase()
            }
            // Cache successful result
            metadataCache.set(cacheKey, { data: result, timestamp: Date.now() })
            return result
          } else {
            console.log(`[DEBUG] ${service.name} metadata failed with status:`, response.status)
          }
        } catch (e) {
          console.log(`[DEBUG] ${service.name} metadata error:`, e.message)
          // Continue to next service
        }
      }

      console.log('[DEBUG] All metadata proxy services failed')
      throw new Error('All metadata services failed')
    }

    // Continuous metadata fetching - runs in parallel to main loop
    async function startContinuousMetadataFetching() {
      if (continuousMetadataActive) return
      continuousMetadataActive = true

      console.log('[DEBUG] Starting continuous metadata fetching')

      const fetchMetadataContinuously = async () => {
        while (continuousMetadataActive) {
          for (const ep of cfg.metaEndpoints) {
            if (!continuousMetadataActive) break

            try {
              metadataFetchCount++
              console.log(`[DEBUG] Continuous fetch #${metadataFetchCount} from:`, ep)

              const {res, via} = await fetchMetadataRobust(ep)
              if (res.ok) {
                const ct = (res.headers.get('content-type') || '').toLowerCase()
                let parsed = null

                if (ct.includes('application/json')) {
                  const json = await res.json()
                  const raw = extractTitleFromJson(json)
                  parsed = splitTitle(typeof raw === 'string' ? raw : '')
                } else {
                  const text = await res.text()
                  try {
                    const j = JSON.parse(text)
                    const raw = extractTitleFromJson(j)
                    parsed = splitTitle(typeof raw === 'string' ? raw : '')
                  } catch(_) {
                    // Parse text-based metadata from different sources
                    parsed = parseTextMetadata(text)
                  }
                }

                if (parsed && (parsed.title || parsed.artist)) {
                  lastMetadataResult = parsed
                  console.log(`[DEBUG] Continuous metadata success via ${via}:`, parsed)
                  // Short delay before next attempt
                  await new Promise(resolve => setTimeout(resolve, 1000))
                  break // Success, exit endpoint loop
                }
              }
            } catch (e) {
              console.log(`[DEBUG] Continuous metadata error:`, e.message)
            }
          }

          // Very short delay between cycles - prioritize metadata!
          await new Promise(resolve => setTimeout(resolve, 500))
        }
      }

      // Start the continuous fetching
      fetchMetadataContinuously().catch(e => {
        console.error('[DEBUG] Continuous metadata fetching error:', e)
        continuousMetadataActive = false
      })
    }

    function stopContinuousMetadataFetching() {
      console.log('[DEBUG] Stopping continuous metadata fetching')
      continuousMetadataActive = false
    }

    async function smartGet(url){
      // add cache-buster to avoid intermediates
      const u = new URL(url, location.href)
      u.searchParams.set('_', Date.now().toString())
      // Force proxy when opened from file:// to avoid CORS/preflight issues
      const mustProxy = location.protocol === 'file:'
      if (mustProxy){
        const base = cfg.proxy || 'https://r.jina.ai/http://'
        const proxUrl = base.includes('r.jina.ai') ? base + u.toString().replace(/^https?:\/\//,'') : base + encodeURIComponent(u.toString())
        const r = await fetchWithTimeout(proxUrl, 8000)
        return {res:r, via: base.includes('r.jina.ai') ? 'jina' : 'proxy'}
      }
      // try direct first when not file://
      try{
        const r = await fetchWithTimeout(u.toString(), 7000)
        if (r.ok) return {res:r, via:'direct'}
        throw new Error('HTTP '+r.status)
      }catch(e){
        // on network/CORS errors, use proxy (explicit or public)
        // Prefer r.jina.ai which avoids CORS preflight for GET
        const base1 = cfg.proxy || 'https://r.jina.ai/http://'
        const p1 = base1.includes('r.jina.ai') ? base1 + u.toString().replace(/^https?:\/\//,'') : base1 + encodeURIComponent(u.toString())
        try{
          const r1 = await fetchWithTimeout(p1, 8000)
          return {res:r1, via: base1.includes('r.jina.ai') ? 'jina' : 'proxy'}
        }catch(_){
          const base2 = 'https://api.allorigins.win/raw?url='
          const r2 = await fetchWithTimeout(base2 + encodeURIComponent(u.toString()), 8000)
          return {res:r2, via:'allorigins'}
        }
      }
    }

    function splitTitle(s){
      if (!s) return { title:'On Air', artist:'Radio Nostalgie' }
      const parts = s.split(/\s[–-]\s/)
      if (parts.length >= 2) return { artist: parts[0].trim(), title: parts.slice(1).join(' - ').trim() }
      const p2 = s.split(/\s:\s/)
      if (p2.length >= 2) return { artist: p2[0].trim(), title: p2.slice(1).join(': ').trim() }
      return { title: s.trim(), artist: 'Radio Nostalgie' }
    }

    function parseTextMetadata(text) {
      console.log('[DEBUG] Parsing text metadata from:', text.substring(0, 200) + '...')

      // Helper function to clean HTML tags and decode entities
      function cleanHtmlText(str) {
        // Remove HTML tags
        let cleaned = str.replace(/<[^>]*>/g, ' ')
        // Decode common HTML entities
        cleaned = cleaned.replace(/&amp;/g, '&')
                         .replace(/&lt;/g, '<')
                         .replace(/&gt;/g, '>')
                         .replace(/&quot;/g, '"')
                         .replace(/&#39;/g, "'")
                         .replace(/&nbsp;/g, ' ')
        // Clean up extra whitespace
        return cleaned.replace(/\s+/g, ' ').trim()
      }

      // Check for "Currently playing:" format first (direct server)
      const currentlyPlayingMatch = text.match(/currently\s+playing:\s*(.+)/im)
      if (currentlyPlayingMatch) {
        const songTitle = cleanHtmlText(currentlyPlayingMatch[1])
        console.log('[DEBUG] Found "Currently playing:" format:', songTitle)
        return splitTitle(songTitle)
      }

      // Check for "Now playing:" format
      const nowPlayingMatch = text.match(/now\s+playing:\s*(.+)/im)
      if (nowPlayingMatch) {
        const songTitle = cleanHtmlText(nowPlayingMatch[1])
        console.log('[DEBUG] Found "Now playing:" format:', songTitle)
        return splitTitle(songTitle)
      }

      // Check for streamstats class content (from your HTML structure)
      const streamstatsMatch = text.match(/class=["']streamstats["'][^>]*>([^<]+)/i)
      if (streamstatsMatch) {
        const songTitle = cleanHtmlText(streamstatsMatch[1])
        console.log('[DEBUG] Found streamstats format:', songTitle)
        return splitTitle(songTitle)
      }

      // Look for content between any HTML tags that might contain song info
      const tagContentMatches = text.match(/>([^<]+)</g)
      if (tagContentMatches) {
        for (const match of tagContentMatches) {
          const content = cleanHtmlText(match.substring(1, match.length - 1))
          // Skip if it's too short, looks like HTML, or contains common non-song words
          if (content.length > 5 &&
              !content.match(/^(html|head|body|div|table|tr|td|span|p)$/i) &&
              !content.match(/^(stream|server|status|radio|live)$/i) &&
              (content.includes(' ') || content.includes('-') || content.includes('–'))) {
            console.log('[DEBUG] Found potential song in HTML tags:', content)
            return splitTitle(content)
          }
        }
      }

      // RCast specific: prefer "Artist – Title" in any line
      const mrc = text.match(/^(.*?)[\s\t]*[–-][\s\t]*(.+)$/m)
      if (mrc) {
        const line = cleanHtmlText(`${mrc[1]} - ${mrc[2]}`)
        console.log('[DEBUG] Found RCast format:', line)
        return splitTitle(line)
      }

      // Fallback: look for any line with separators
      const lines = text.split(/\n|\r/)
      for (const line of lines) {
        const cleanLine = cleanHtmlText(line)
        if (cleanLine.length > 5 && /[-–:]/.test(cleanLine) && !/<|>/.test(cleanLine)) {
          console.log('[DEBUG] Found line with separator:', cleanLine)
          return splitTitle(cleanLine)
        }
      }

      // Last resort: use first substantial non-HTML line
      for (const line of lines) {
        const cleanLine = cleanHtmlText(line)
        if (cleanLine.length > 3 && !/<|>/.test(cleanLine) &&
            !cleanLine.match(/^(html|head|body|div|table|tr|td|span|p|script|style)$/i)) {
          console.log('[DEBUG] Using first substantial line:', cleanLine)
          return splitTitle(cleanLine)
        }
      }

      console.log('[DEBUG] No parseable metadata found')
      return null
    }

    let metaTimerId = null
    function scheduleNext(ms){
      const delay = Math.max(500, ms|0)  // Allow polling as fast as 500ms
      if (metaTimerId) clearTimeout(metaTimerId)
      metaTimerId = setTimeout(updateMeta, delay)
    }

    async function updateMeta(){
      console.log('[DEBUG] updateMeta called')
      let parsed = null

      // First, check if we have fresh results from continuous fetching
      if (lastMetadataResult) {
        parsed = lastMetadataResult
        console.log('[DEBUG] Using continuous metadata result:', parsed)
      } else {
        // Fallback to traditional fetching if continuous isn't working
        console.log('[DEBUG] No continuous result available, trying traditional fetch')

        for (const ep of cfg.metaEndpoints){
          console.log('[DEBUG] Fetching metadata from:', ep)
          try{
            const {res, via} = await fetchMetadataRobust(ep)
            console.log('[DEBUG] Fetch successful via:', via, 'status:', res.status)
            if (!res.ok) throw new Error('HTTP '+res.status)
            const ct = (res.headers.get('content-type') || '').toLowerCase()
            console.log('[DEBUG] Content-Type:', ct)
            if (ct.includes('application/json')){
              const json = await res.json()
              console.log('[DEBUG] JSON response:', json)
              const raw = extractTitleFromJson(json)
              console.log('[DEBUG] Extracted title:', raw)
              parsed = splitTitle(typeof raw === 'string' ? raw : '')
            } else {
              const text = await res.text()
              console.log('[DEBUG] Text response:', text.substring(0, 200) + '...')
              // attempt JSON first
              try {
                const j = JSON.parse(text)
                const raw = extractTitleFromJson(j)
                parsed = splitTitle(typeof raw === 'string' ? raw : '')
              } catch(_) {
                // Parse text-based metadata from different sources
                parsed = parseTextMetadata(text)
              }
            }
            console.log('[DEBUG] Parsed metadata:', parsed)
            if (parsed && (parsed.title || parsed.artist)) break
          } catch (e) {
            console.warn('[DEBUG] Meta fetch failed for', ep, e)
          }
        }
      }

      if (!parsed){
        console.log('[DEBUG] No metadata parsed, scheduling next update')
        // Ensure we continue polling even if a cycle yielded no parseable metadata
        scheduleNext(cfg.refreshMs)
        return
      }
      const key = `${parsed.artist}—${parsed.title}`
      console.log('[DEBUG] Song key:', key, 'lastSongKey:', lastSongKey)
      let changed = false
      if (key !== lastSongKey){
        console.log('[DEBUG] Song changed! Updating UI and cover')
        lastSongKey = key

        // Check if artist is jingle or reklama (case-insensitive)
        const artistLower = (parsed.artist || '').toLowerCase()
        const isAd = artistLower === 'jingle' || artistLower === 'reklama'

        if (isAd) {
          // Display advertisement contact info
          titleEl.textContent = parsed.title
          artistEl.innerHTML = `${parsed.artist} • <span style="color: #ff7a59;">Реклама на радио 8(988) 293-50-25</span>`
          console.log('[DEBUG] Detected jingle/reklama, displaying ad contact')
        } else {
        // Normal song display
          titleEl.textContent = parsed.title
          artistEl.textContent = parsed.artist
        }

        await setCover(parsed)
        changed = true
      }
      // If song hasn't changed but the cover is still the default, retry lookup occasionally (helps iOS/CDN lag)
      else {
        const imgEl = document.getElementById('coverImg')
        const curSrcAttr = imgEl ? (imgEl.getAttribute('src') || '') : ''
        const looksDefault = !curSrcAttr || curSrcAttr.indexOf(cfg.defaultCover) !== -1
        const stale = Date.now() - lastCoverAttemptTs > 3000
        console.log('[DEBUG] Song unchanged. Current src:', curSrcAttr, 'looksDefault:', looksDefault, 'stale:', stale)
        if (cfg.autoCover && looksDefault && stale) {
          console.log('[DEBUG] Retrying cover lookup for same song')
          lastCoverAttemptKey = lastSongKey
          lastCoverAttemptTs = Date.now()
          await setCover(parsed)
        }
      }
      // schedule next poll adaptively: faster while playing, slower when idle
      if (changed){
        scheduleNext(500)  // Very fast follow-up after song change
      } else {
        // More frequent checks when playing to catch song changes quickly
        const playingInterval = Math.min(cfg.fastMs, 1500)  // Cap at 1.5 seconds max
        scheduleNext(!audio.paused ? playingInterval : cfg.refreshMs)
      }
      console.log('[DEBUG] updateMeta completed, next update in:', changed ? 500 : (!audio.paused ? Math.min(cfg.fastMs, 1500) : cfg.refreshMs), 'ms')
    }

    async function setCover({artist, title}){
      console.log('[DEBUG] setCover called with artist:', artist, 'title:', title)
      lastCoverAttemptKey = lastSongKey
      lastCoverAttemptTs = Date.now()
      // Prefer dynamic template if available
      if (cfg.coverTpl){
        console.log('[DEBUG] Using coverTpl:', cfg.coverTpl)
        const url = cfg.coverTpl.replaceAll('{artist}', encodeURIComponent(artist)).replaceAll('{title}', encodeURIComponent(title))
        return paintCover(url)
      }
      // Provider template comes before static provider cover if present
      if (cfg.providerCoverTpl){
        console.log('[DEBUG] Using providerCoverTpl:', cfg.providerCoverTpl)
        const url = cfg.providerCoverTpl.replaceAll('{artist}', encodeURIComponent(artist)).replaceAll('{title}', encodeURIComponent(title))
        return paintCover(url)
      }
      // Try explicit provider cover first (e.g., 101.ru image URL)
      if (cfg.providerCover){
        console.log('[DEBUG] Using providerCover:', cfg.providerCover)
        return paintCover(cfg.providerCover)
      }
      if (cfg.cover){
        console.log('[DEBUG] Using cover endpoint:', cfg.cover)
        // rcast artwork endpoint returns a text body containing the actual image URL.
        // If it's already an image URL, paint it directly; otherwise resolve via smartGet.
        const looksLikeImage = /\.(jpg|jpeg|png|webp|gif)(\?.*)?$/i.test(cfg.cover)
        if (looksLikeImage){ return paintCover(cfg.cover) }
        return resolveAndPaintCoverFromEndpoint(cfg.cover)
      }
      if (cfg.autoCover){
        console.log('[DEBUG] Trying autoCover with Apple iTunes')
        // Simplified strategy: always try Apple first (more accurate artwork).
        // Regional blocks are handled by retry + size candidates and default fallback.
        const found = await tryAppleCover(artist, title)
        console.log('[DEBUG] Apple cover result:', found)
        if (found) return paintCover(found)

        // iOS fallback: try Deezer if Apple fails
        if (isIOS) {
          console.log('[DEBUG] iOS Apple failed, trying Deezer fallback')
          const deezerCover = await tryDeezerCover(artist, title)
          console.log('[DEBUG] Deezer cover result:', deezerCover)
          if (deezerCover) return paintCover(deezerCover)
        }
      }
      // fallback visual
      console.log('[DEBUG] Falling back to default cover')
      const imgEl = document.getElementById('coverImg');
      if (imgEl){ imgEl.src = cfg.defaultCover }
    }

    function normalizeQuery(s){
      return (s||'').replace(/[“”"']/g,'').replace(/\s+/g,' ').trim()
    }

    async function tryDeezerCover(artist, title){
      try{
        const q = `artist:"${normalizeQuery(artist)}" track:"${normalizeQuery(title)}"`
        const url = `https://api.deezer.com/search?q=${encodeURIComponent(q)}&limit=1&_=${Date.now()}`
        const r = await fetchWithTimeout(url, 6000)
        if (!r.ok) return ''
        const j = await r.json()
        const item = j && j.data && j.data[0]
        const img = item && (item.album?.cover_xl || item.album?.cover_big || item.album?.cover_medium)
        return typeof img === 'string' ? img : ''
      }catch{ return '' }
    }

    async function tryAppleCover(artist, title){
      try{
        const term1 = normalizeQuery(`${artist} ${title}`)
        const term2 = normalizeQuery(`${title} ${artist}`)
        if (!term1) return ''
        // Prefer global endpoints first to avoid RU redirect to musics.mzstoreservices
        const bases = [
          `https://itunes.apple.com/search?term=${encodeURIComponent(term1)}&media=music&entity=song&limit=1&_=${Date.now()}`,
          `https://itunes.apple.com/search?term=${encodeURIComponent(term2)}&media=music&entity=song&limit=1&_=${Date.now()}`,
          `https://itunes.apple.com/search?term=${encodeURIComponent(term1)}&media=music&entity=album&limit=1&_=${Date.now()}`,
          `https://itunes.apple.com/search?term=${encodeURIComponent(term1)}&media=music&entity=song&country=ru&limit=1&_=${Date.now()}`
        ]

        const fetchAppleJson = async (url) => {
          // Check cache first to avoid unnecessary API calls
          const cacheKey = url
          const cached = itunesCache.get(cacheKey)
          if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
            console.log('[DEBUG] Using cached iTunes result')
            return cached.data
          }

          // Multiple proxy services optimized for speed (especially from Russia)
          const proxyServices = [
            {
              name: 'AllOrigins',
              url: 'https://api.allorigins.win/raw?url=' + encodeURIComponent(url),
              timeout: 4000,  // Faster timeout
              parseJson: (response) => response.json()
            },
            {
              name: 'Jina',
              url: 'https://r.jina.ai/http://' + url.replace(/^https?:\/\//, ''),
              timeout: 4000,  // Faster timeout
              parseJson: async (response) => {
                const text = await response.text()
                // Extract JSON from jina's Markdown wrapper
                const jsonMatch = text.match(/```(?:json)?\s*\n?([\s\S]*?)\n?```/) || text.match(/\{[\s\S]*\}/)
                const jsonText = jsonMatch ? jsonMatch[1] || jsonMatch[0] : text
                return JSON.parse(jsonText.trim())
              }
            },
            {
              name: 'CORS-Anywhere',
              url: 'https://cors-anywhere.herokuapp.com/' + url,
              timeout: 4000,  // Faster timeout
              parseJson: (response) => response.json()
            },
            {
              name: 'ProxyNova',
              url: 'https://api.proxynova.com/cgi-bin/proxy.cgi?u=' + encodeURIComponent(url),
              timeout: 4000,  // Faster timeout
              parseJson: (response) => response.json()
            }
          ]

          console.log('[DEBUG] Trying multiple proxy services for iTunes API:', url)

          // Try each proxy service with shorter timeouts to fail fast
          for (const service of proxyServices) {
            try {
              console.log(`[DEBUG] Trying ${service.name} proxy:`, service.url)
              const response = await fetchWithTimeout(service.url, service.timeout)

              if (response.ok) {
                const json = await service.parseJson(response)
                if (json && json.results) {
                  console.log(`[DEBUG] ${service.name} proxy success!`)
                  // Cache successful result
                  itunesCache.set(cacheKey, { data: json, timestamp: Date.now() })
                  return json
                }
                console.log(`[DEBUG] ${service.name} returned data but no results`)
              } else {
                console.log(`[DEBUG] ${service.name} proxy failed with status:`, response.status)
              }
            } catch (e) {
              console.log(`[DEBUG] ${service.name} proxy error:`, e.message)
              // Continue to next service
            }
          }

          console.log('[DEBUG] All proxy services failed for iTunes API')
          return null
        }

        for (const url of bases){
          const j = await fetchAppleJson(url)
          if (!j) continue
          const it = j && Array.isArray(j.results) && j.results[0]
          const base = it && (it.artworkUrl100 || it.artworkUrl60 || it.artworkUrl30)
          if (typeof base === 'string' && base) return base
        }
        return ''
      }catch{ return '' }
    }

    async function tryMBZCover(artist, title){
      try{
        const q = `artist:"${normalizeQuery(artist)}" recording:"${normalizeQuery(title)}"`
        const url = `https://musicbrainz.org/ws/2/recording?query=${encodeURIComponent(q)}&fmt=json&limit=1&_=${Date.now()}`
        const r = await fetchWithTimeout(url, 7000)
        if (!r.ok) return ''
        const j = await r.json()
        const rec = j && j.recordings && j.recordings[0]
        const rel = rec && rec.releases && rec.releases[0]
        const mbid = rel && rel.id
        if (!mbid) return ''
        // CAA direct image; allow redirect by using the URL as img src later
        return `https://coverartarchive.org/release/${mbid}/front`
      }catch{ return '' }
    }

    function withCacheBuster(url){
      try{
        const u = new URL(url)
        u.searchParams.set('_', Date.now().toString())
        return u.toString()
      }catch{ return url }
    }

    function itunesCandidates(base){
      // base e.g. .../100x100bb.jpg; build variants in order of preference
      const sizes = [600, 512, 400, 300, 200, 100, 60, 30]
      const out = []
      const m = base.match(/\/(\d+)x\d+bb\./)
      if (m){
        const ext = base.split(/bb\./).pop() // e.g. 'jpg'
        for (const s of sizes){ out.push(base.replace(/\/(?:\d+)x(?:\d+)bb\.[^/]+$/, `/${s}x${s}bb.${ext}`)) }
      }
      // ensure base last
      if (!out.includes(base)) out.push(base)
      return out
    }

    async function paintCover(url){
      const imgEl = document.getElementById('coverImg')
      if (!imgEl) {
        console.error('[DEBUG] coverImg element not found!')
        return
      }
      console.log('[DEBUG] paintCover called with:', url, 'isIOS:', isIOS)
      console.log('[DEBUG] current img src:', imgEl.getAttribute('src'))

      // Ensure default cover is always set first
      if (!imgEl.getAttribute('src') || imgEl.getAttribute('src') === '') {
        console.log('[DEBUG] Setting default cover:', cfg.defaultCover)
        imgEl.src = cfg.defaultCover
      }

      // Build candidate list (Apple sizes) if needed
      const list = Array.isArray(url) ? url : (url.includes('mzstatic.com') ? itunesCandidates(url) : [url])

      let i = 0
      const perAttempt = isIOS ? 4000 : 3000  // Much faster image loading timeouts

      function nextCandidate(){
        if (i >= list.length){
          // Nothing worked — ensure default is shown
          imgEl.src = cfg.defaultCover
          return
        }
        const u = list[i++]
        console.log('[DEBUG] Trying candidate', i, 'of', list.length, ':', u)
        const test = new Image()
        // Only set referrerPolicy for external URLs, not local files
        if (!u.includes('nostalgielogo.jpeg') && !u.startsWith('file://')) {
          test.referrerPolicy = 'no-referrer'
        }
        test.decoding = 'async'
        const timer = setTimeout(() => {
          // Timeout hit — try next candidate
          console.log('[DEBUG] Timeout for:', u)
          test.onload = test.onerror = null
          // iOS-specific: ensure fallback on timeout
          if (isIOS && i === list.length) {
            console.log('[DEBUG] iOS: Last candidate timed out, setting default cover')
            imgEl.src = cfg.defaultCover
          }
          nextCandidate()
        }, perAttempt)
        test.onload = () => {
          clearTimeout(timer)
          console.log('[DEBUG] Successfully loaded:', u)
          // On success, swap the visible image src to this candidate
          imgEl.src = u
          console.log('[DEBUG] Set img src to:', u)
        }
        test.onerror = () => {
          clearTimeout(timer)
          console.log('[DEBUG] Failed to load:', u)
          // iOS-specific: ensure we always have a fallback image
          if (isIOS && i === list.length) {
            console.log('[DEBUG] iOS: Last candidate failed, setting default cover')
            imgEl.src = cfg.defaultCover
          }
          nextCandidate()
        }
        // Avoid cache-busting on iOS entirely; otherwise only for non-Apple images
        const finalUrl = (isIOS || u.includes('mzstatic.com')) ? u : withCacheBuster(u)
        console.log('[DEBUG] Final URL:', finalUrl)
        test.src = finalUrl
      }
      nextCandidate()
    }

    let lastCoverKey = ''
    async function resolveAndPaintCoverFromEndpoint(endpoint){
      // Only resolve once per song change to avoid rate limiting
      if (lastCoverKey === lastSongKey){ return }
      lastCoverKey = lastSongKey
      const baseUrl = new URL(endpoint, location.href).toString()

      const fetchVia = async (base, label) => {
        const prox = base + encodeURIComponent(baseUrl)
        console.info('[cover] via', label, prox)
        const r = await fetchWithTimeout(prox, 9000)
        if (!r.ok) throw new Error(label+': HTTP '+r.status)
        const text = await r.text()
        const urls = Array.from(text.matchAll(/https?:\/\/\S+/g)).map(m=>m[0].replace(/[\)"'<>\s].*$/,''))
        const imgUrl = urls.find(u=>/\.(png|jpe?g|webp|gif)(\?.*)?$/i.test(u)) || urls.pop()
        console.info('[cover] candidates', urls, 'chosen', imgUrl)
        if (imgUrl) { await paintCover(imgUrl); return true }
        return false
      }

      // Choose a single proxy path, keep it quiet on failures
      try{
        if (cfg.proxy){ if (await fetchVia(cfg.proxy, 'custom-proxy')) return }
        if (await fetchVia('https://api.allorigins.win/raw?url=', 'allorigins')) return
        // one quiet fallback
        const jina = 'https://r.jina.ai/http://'
        const prox = jina + baseUrl.replace(/^https?:\/\//,'')
        console.info('[cover] via jina', prox)
        const r = await fetchWithTimeout(prox, 9000)
        const text = await r.text()
        const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean)
        const last = lines[lines.length-1] || ''
        const urls = Array.from(text.matchAll(/https?:\/\/\S+/g)).map(m=>m[0].replace(/[\)"'<>\s].*$/,''))
        if (last && /^https?:\/\//.test(last)) urls.push(last)
        const imgUrl = urls.find(u=>/\.(png|jpe?g|webp|gif)(\?.*)?$/i.test(u)) || urls.pop()
        console.info('[cover] jina chosen', imgUrl)
        if (imgUrl){ await paintCover(imgUrl); return }
      }catch(e){ console.warn('[cover] resolve failed', e) }
      // Ensure default cover on failure
      const imgEl = document.getElementById('coverImg')
      if (imgEl) imgEl.src = cfg.defaultCover
    }

    // ---- boot ----
    console.log('[DEBUG] App starting. iOS detected:', isIOS)
    console.log('[DEBUG] Config:', cfg)

    // kick off cover resolution immediately if a cover endpoint was provided
    if (cfg.cover && !/\.(png|jpe?g|webp|gif)(\?.*)?$/i.test(cfg.cover)){
      console.log('[DEBUG] Resolving cover from endpoint:', cfg.cover)
      resolveAndPaintCoverFromEndpoint(cfg.cover)
    }

    console.log('[DEBUG] Starting continuous metadata fetching')
    startContinuousMetadataFetching()

    console.log('[DEBUG] Starting metadata update')
    updateMeta()

    // ---- tiny tests (non-breaking, console only) ----
    // production: no debug logs
  })()
  </script>
  <script>
  // Helper extracted to widen JSON compatibility for metadata endpoints
  function extractTitleFromJson(json){
    try{
      // Common fields
      const direct = json.title || json.song || json.streamtitle || json.nowplaying
      if (typeof direct === 'string' && direct.trim()) return direct

      // Icecast / Shoutcast style
      const ice1 = json?.icestats?.source?.title
      if (typeof ice1 === 'string' && ice1.trim()) return ice1

      // Alternative popular schemas
      const np1 = json?.now_playing?.song?.text || json?.now_playing?.song?.title
      if (typeof np1 === 'string' && np1.trim()) return np1
      const cur = json?.current?.title || json?.currentSong || json?.current_title
      if (typeof cur === 'string' && cur.trim()) return cur
      const meta = json?.metadata?.title || json?.meta?.title
      if (typeof meta === 'string' && meta.trim()) return meta

      // Try flatten known combos like "Artist - Title"
      const artist = json?.artist || json?.now_playing?.song?.artist || json?.current?.artist
      const title = json?.title || json?.now_playing?.song?.title || json?.current?.title
      if (artist && title) return `${artist} - ${title}`
    }catch(_){ /* noop */ }
    return ''
  }
  </script>
  <script defer src="https://static.cloudflareinsights.com/beacon.min.js"
    data-cf-beacon='{"token":"53e240a7a36248fc8b15db80cebfd568"}'>
    </script>
</body>
</html>
